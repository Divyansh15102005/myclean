import asyncio
import datetime
from pymongo import MongoClient
from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters
)

# MongoDB setup
MONGO_URI = "mongodb+srv://ajaysatbhaiya2:dLZCnGpVw6lpDqgd@elitebot.hdw8vtg.mongodb.net/?retryWrites=true&w=majority"
client = MongoClient(MONGO_URI)
db = client["mlm_bot"]
users = db["users"]
transactions = db["transactions"]

# Admin and payment details
ADMIN_ID = 5856521394
UPI_ID = "9889036619@pthdfc"

# ========== Handlers ==========

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    ref = int(context.args[0]) if context.args else None

    if not users.find_one({"user_id": user.id}):
        users.insert_one({
            "user_id": user.id,
            "username": user.username,
            "ref_by": ref,
            "points": 0,
            "paid": False,
            "joined": datetime.datetime.now()
        })

        await update.message.reply_text(
            "ЁЯОЙ рдмрдзрд╛рдИ рд╣реЛ! рдЖрдкрдиреЗ рдмреЙрдЯ рдХреЛ рдЬреЙрдЗрди рдХрд░ рд▓рд┐рдпрд╛ рд╣реИред\n\n"
            "ЁЯТ╝ Network Marketing Plan:\n"
            "тЬЕ тВ╣500 рдореЗрдВ рдЗрд╕ рдмреЙрдЯ рдХрд╛ Premium Member рдмрдиреЗрдВ\n"
            "тЬЕ рдФрд░ referral рд╕реЗ тВ╣20,000 рд╕реЗ тВ╣30,000+ рдорд╣реАрдирд╛ рддрдХ рдХрдорд╛рдПрдБ\n\n"
            "ЁЯТ╕ Referral Commission Structure:\n"
            "ЁЯСе Level 1 (Direct): тВ╣200 рдкреНрд░рддрд┐ рд╕рджрд╕реНрдп\n"
            "ЁЯСе Level 2: тВ╣120 рдкреНрд░рддрд┐ рд╕рджрд╕реНрдп\n"
            "ЁЯСе Level 3: тВ╣80 рдкреНрд░рддрд┐ рд╕рджрд╕реНрдп\n\n"
            "ЁЯФР Important:\n"
            "рдмрд┐рдирд╛ тВ╣500 рдкреЗрдореЗрдВрдЯ рдХрд┐рдП рдЖрдк рд░реЗрдлрд░рд▓ рд▓рд┐рдВрдХ рдирд╣реАрдВ рдмрдирд╛ рд╕рдХрддреЗ рдФрд░ рдХрдорд╛рдИ рд╢реБрд░реВ рдирд╣реАрдВ рд╣реЛрдЧреАред\n\n"
            "ЁЯкЩ рдкреЗрдореЗрдВрдЯ рдХреЗ рд▓рд┐рдП /pay рдХрдорд╛рдВрдб рднреЗрдЬреЗрдВред\n"
            "ЁЯЩЛтАНтЩВ рдФрд░ рдорджрдж рдХреЗ рд▓рд┐рдП /help рдЯрд╛рдЗрдк рдХрд░реЗрдВред"
        )
    else:
        await update.message.reply_text(
            "тЬЕ рдЖрдк рдкрд╣рд▓реЗ рд╕реЗ рд░рдЬрд┐рд╕реНрдЯрд░ рд╣реИрдВред\n"
            "ЁЯТб рдХрдорд╛рдИ рд╢реБрд░реВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП тВ╣500 рдкреЗ рдХрд░реЗрдВ тАУ /pay рдЯрд╛рдЗрдк рдХрд░реЗрдВред"
        )

async def referral_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = users.find_one({"user_id": update.effective_user.id})
    if not user or not user.get("paid", False):
        await update.message.reply_text("тЭМ рдЖрдк рддрдм рддрдХ рд░реЗрдлрд░ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ рдЬрдм рддрдХ тВ╣500 рдкреЗрдореЗрдВрдЯ рди рдХрд░реЗрдВред\n/pay рдХрдорд╛рдВрдб рд╕реЗ рдкреЗ рдХрд░реЗрдВред")
        return

    bot_username = (await context.bot.get_me()).username
    await update.message.reply_text(
        f"ЁЯФЧ рдЖрдкрдХрд╛ рд░реЗрдлрд░рд▓ рд▓рд┐рдВрдХ:\nhttps://t.me/{bot_username}?start={update.effective_user.id}"
    )

async def approve_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("тЭМ рдпрд╣ рдХрдорд╛рдВрдб рдХреЗрд╡рд▓ Admin рдХреЗ рд▓рд┐рдП рд╣реИред")
        return

    try:
        user_id = int(update.message.text.split("_")[1])
        user = users.find_one({"user_id": user_id})
        if not user:
            await update.message.reply_text("тЭМ рдпреВрдЬрд╝рд░ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")
            return

        if user["paid"]:
            await update.message.reply_text("тЬЕ рдЗрд╕ рдпреВрдЬрд╝рд░ рдиреЗ рдкрд╣рд▓реЗ рд╣реА рдкреЗрдореЗрдВрдЯ рдХрд░ рджрд┐рдпрд╛ рд╣реИред")
            return

        users.update_one({"user_id": user_id}, {"$set": {"paid": True}})

        await context.bot.send_message(chat_id=user_id,
            text="тЬЕ рдЖрдкрдХрд╛ рдкреЗрдореЗрдВрдЯ рдЕрдкреНрд░реВрд╡ рд╣реЛ рдЧрдпрд╛ рд╣реИ! рдЕрдм рдЖрдк рдХрдорд╛рдиреЗ рдФрд░ рд░реЗрдлрд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рддреИрдпрд╛рд░ рд╣реИрдВред"
        )
        await update.message.reply_text(f"тЬЕ @{user.get('username', 'User')} рдХрд╛ рдкреЗрдореЗрдВрдЯ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдкреНрд░реВрд╡ рдХрд┐рдпрд╛ рдЧрдпрд╛ред")
    except Exception as e:
        await update.message.reply_text(f"тЪа Error: {str(e)}")

async def myteam(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    level1 = list(users.find({"ref_by": uid}))
    level2 = list(users.find({"ref_by": {"$in": [u["user_id"] for u in level1]}}))
    level3 = list(users.find({"ref_by": {"$in": [u["user_id"] for u in level2]}}))
    await update.message.reply_text(
        f"ЁЯСе рдЯреАрдо:\nLevel 1: {len(level1)}\nLevel 2: {len(level2)}\nLevel 3: {len(level3)}"
    )

async def profile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = users.find_one({"user_id": update.effective_user.id})
    if user:
        await update.message.reply_text(
            f"ЁЯзСтАНЁЯТ╝ рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓:\nUsername: @{user.get('username','anonymous')}\nPoints: {user.get('points',0)}\nPaid: {'тЬЕ' if user.get('paid') else 'тЭМ'}"
        )
    else:
        await update.message.reply_text("тЭМ рдЖрдк рд░рдЬрд┐рд╕реНрдЯрд░ рдирд╣реАрдВ рд╣реИрдВред")

async def top_referrers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    top = users.aggregate([
        {"$group": {"_id": "$ref_by", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}},
        {"$limit": 10}
    ])
    msg = "ЁЯПЖ Top Referrers:\n\n"
    for u in top:
        ref = users.find_one({"user_id": u["_id"]})
        if ref:
            msg += f"@{ref.get('username','anonymous')} - {u['count']} referrals\n"
        else:
            msg += f"UserID {u['_id']} - {u['count']} referrals (user not found)\n"
    await update.message.reply_text(msg)

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("""
ЁЯУШ рдЙрдкрд▓рдмреНрдз рдХрдорд╛рдВрдбреНрд╕:
/start [id] тАУ рдмреЙрдЯ рдЬреЙрдЗрди рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП
/referral_link тАУ рдЕрдкрдирд╛ рд░реЗрдлрд░рд▓ рд▓рд┐рдВрдХ рдкрд╛рдиреЗ рдХреЗ рд▓рд┐рдП
/myteam тАУ рдЕрдкрдиреА рдЯреАрдо рджреЗрдЦрдиреЗ рдХреЗ рд▓рд┐рдП
/profile тАУ рдпреВрдЬрд╝рд░ рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓
/points тАУ рдЕрдкрдиреЗ рдкреЙрдЗрдВрдЯреНрд╕ рдЪреЗрдХ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП
/top_referrers тАУ рд╕рдмрд╕реЗ рдЬрд╝реНрдпрд╛рджрд╛ рд░реЗрдлрд░ рдХрд░рдиреЗ рд╡рд╛рд▓реЗ
/help тАУ рд╕рднреА рдХрдорд╛рдВрдбреНрд╕ рдХреА рдЬрд╛рдирдХрд╛рд░реА
/teamtree тАУ 3-рд▓реЗрд╡рд▓ рд░реЗрдлрд░рд▓ рдЯреНрд░реА
/rewards тАУ рдЗрдирд╛рдо рдХреА рдЬрд╛рдирдХрд╛рд░реА
/stats тАУ рдЕрдкрдиреЗ рдиреЗрдЯрд╡рд░реНрдХ рдХрд╛ рдЖрдБрдХрдбрд╝рд╛
/broadcast тАУ рд╕рднреА рдпреВрдЬрд╝рд░реНрд╕ рдХреЛ admin рдХрд╛ рдореИрд╕реЗрдЬ
/level тАУ рдХрд┐рд╕ рд▓реЗрд╡рд▓ рдореЗрдВ рдХреМрди рд╣реИ
/pay тАУ тВ╣500 рдкреЗрдореЗрдВрдЯ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП
/confirm_payment тАУ Admin рджреНрд╡рд╛рд░рд╛ payment approve рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП
/withdraw тАУ рдкреИрд╕реЗ рдирд┐рдХрд╛рд▓рдиреЗ рдХреА рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ
/transactions тАУ рдкреЗрдореЗрдВрдЯ рд╣рд┐рд╕реНрдЯреНрд░реА
""")

async def teamtree(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    tree = f"ЁЯМ│ Referral Tree for {user.username}:\n"
    def fetch_level(uid, level=1):
        members = list(users.find({"ref_by": uid}))
        lines = ""
        for m in members:
            lines += "тАФ" * level + f" @{m.get('username','anonymous')}\n"
            lines += fetch_level(m["user_id"], level + 1)
        return lines
    tree += fetch_level(user.id)
    await update.message.reply_text(tree or "рдХреЛрдИ рдЯреАрдо рдореЗрдВрдмрд░ рдирд╣реАрдВ рд╣реИред")

async def rewards(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ЁЯОБ Rewards:\nLevel 1: тВ╣200\nLevel 2: тВ╣120\nLevel 3: тВ╣80")

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    count = users.count_documents({"ref_by": uid})
    await update.message.reply_text(f"ЁЯУК рдХреБрд▓ рд░реЗрдлрд░рд▓: {count}")

async def level(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lvl1 = users.find({"ref_by": uid})
    msg = "ЁЯУ╢ рдЯреАрдо рд╕реНрддрд░:\n"
    for l1 in lvl1:
        msg += f"ЁЯСд @{l1.get('username','anonymous')} (L1)\n"
        lvl2 = users.find({"ref_by": l1["user_id"]})
        for l2 in lvl2:
            msg += f"   тФФ @{l2.get('username','anonymous')} (L2)\n"
            lvl3 = users.find({"ref_by": l2["user_id"]})
            for l3 in lvl3:
                msg += f"       тФФ @{l3.get('username','anonymous')} (L3)\n"
    await update.message.reply_text(msg or "рдХреЛрдИ рдЯреАрдо рдирд╣реАрдВ")

async def pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        f"ЁЯТ╡ тВ╣500 рдкреЗрдореЗрдВрдЯ рдХрд░реЗрдВ рдЗрд╕ UPI рдкрд░:\nЁЯСЙ {UPI_ID}\nрдлрд┐рд░ /confirm_payment рдХрдорд╛рдВрдб рднреЗрдЬреЗрдВред"
    )

async def confirm_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if users.find_one({"user_id": user.id})["paid"]:
        await update.message.reply_text("тЬЕ рдЖрдкрдиреЗ рдкрд╣рд▓реЗ рд╣реА рдкреЗрдореЗрдВрдЯ рдХрд┐рдпрд╛ рд╣реИред")
        return
    await context.bot.send_message(
        chat_id=ADMIN_ID,
        text=f"ЁЯУе рдпреВрдЬрд╝рд░ @{user.username} рдиреЗ тВ╣500 рдкреЗрдореЗрдВрдЯ рдХрд┐рдпрд╛ рд╣реИред Confirm рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП /approve_{user.id} рднреЗрдЬреЗрдВред"
    )
    await update.message.reply_text("ЁЯХР рдЖрдкрдХрд╛ рдкреЗрдореЗрдВрдЯ admin рдХреЗ рдкрд╛рд╕ рднреЗрдЬ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")

async def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    msg = " ".join(context.args)
    for user in users.find():
        try:
            await context.bot.send_message(chat_id=user["user_id"], text=msg)
        except:
            pass
    await update.message.reply_text("ЁЯУд Broadcast рднреЗрдЬ рджрд┐рдпрд╛ рдЧрдпрд╛ред")

async def withdraw(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ЁЯз╛ Withdraw system рдЕрднреА рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИред")

async def transactions_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ЁЯз╛ Transactions system рдЕрднреА рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИред")

# ========== Main ==========

async def main():
    print("тЬЕ MongoDB Connected")
    app = ApplicationBuilder().token("8061361833:AAF9VUVxv1Fdf0dOhYqqCXrDnZaRRDMvS5I").build()

    # All handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("referral_link", referral_link))
    app.add_handler(MessageHandler(filters.Regex(r"^/approve_\d+$"), approve_payment))
    app.add_handler(CommandHandler("myteam", myteam))
    app.add_handler(CommandHandler("profile", profile))
    app.add_handler(CommandHandler("top_referrers", top_referrers))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("teamtree", teamtree))
    app.add_handler(CommandHandler("rewards", rewards))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CommandHandler("level", level))
    app.add_handler(CommandHandler("pay", pay))
    app.add_handler(CommandHandler("confirm_payment", confirm_payment))
    app.add_handler(CommandHandler("broadcast", broadcast))
    app.add_handler(CommandHandler("withdraw", withdraw))
    app.add_handler(CommandHandler("transactions", transactions_cmd))

    print("ЁЯдЦ Bot is running...")
    await app.run_polling()

# ========== Run ==========

if __name__ == "__main__":
    asyncio.run(main())
